#!/usr/bin/env python3


import sys
import os
import jinja2
import subprocess
import tempfile
import shutil
import yaml
from collections import OrderedDict
from typing import Union, Tuple, List
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC


def ordered_load(stream, Loader=yaml.SafeLoader, object_pairs_hook=OrderedDict):
    """Usage:
    ordered_load(stream, yaml.SafeLoader)
    From: https://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-mappings-as-ordereddicts
    """

    class OrderedLoader(Loader):
        pass

    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))

    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping
    )
    return yaml.load(stream, OrderedLoader)


def unroll_loops(lst: List[OrderedDict]) -> List[OrderedDict]:
    """
    Unroll dictionaries containing a "loop" key with a list of dictionaries as its value.

    This function iterates through a list of dictionaries, and if an item
    has a "loop" key, it replaces the item with one item for each of the
    elements in the "loop" value list.  The new items are created by merging
    the outer dictionary with each inner dictionary, overwriting any keys
    in the outer dictionary with the values from the inner dictionary.

    Args:
        lst (List[OrderedDict]): A list of dictionaries, with some dictionaries
                potentially containing a "loop" key and a list of dictionaries as
                its value.

    Returns:
        List[OrderedDict]: A new list of dictionaries with the "loop" items unrolled.
    """
    result = []
    for task in lst:
        if "loop" in task:
            for item in task["loop"]:
                merged = OrderedDict()
                merged.update(task)
                merged.update(item)
                del merged["loop"]
                result.append(merged)
        else:
            result.append(task)
    return result


def generate_salt() -> bytes:
    return os.urandom(16)


def fernet_key(password: bytes, salt: bytes) -> Fernet:
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=960000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(password))
    return Fernet(key)


def fernet_encrypt(filename: str, password: bytes) -> bytes:
    salt = generate_salt()
    f = fernet_key(password, salt)
    with open(filename, "rb") as fp:
        return salt + f.encrypt(fp.read())


def fernet_decrypt(filename: str, password: bytes) -> bytes:
    with open(filename, "rb") as fp:
        salt = fp.read(16)
        f = fernet_key(password, salt)
        return f.decrypt(fp.read())


class CommandProcessor:
    def __init__(self):
        self.config = {"environ": os.environ}

        self.jinja_env = jinja2.Environment()
        self.jinja_env.filters['basename'] = os.path.basename
        self.jinja_env.filters['dirname'] = os.path.dirname
        self.jinja_env.filters['abspath'] = os.path.abspath

    def jinja_expand_str(self, s: str, env_in: Union[None, dict] = None) -> str:
        env = self.config.copy()
        if env_in != None:
            env.update(env_in)
        return self.jinja_env.from_string(s).render(env)

    def jinja_expand_dict(self, d: dict) -> dict:
        env = self.config.copy()
        env.update(d)
        results = {}
        for k, v in d.items():
            newv = self.jinja_env.from_string(v).render(env)
            env[k] = newv
            results[k] = newv

        return results

    def encrypt(self, src: str, password: str) -> str:
        dstfd, dst = tempfile.mkstemp()
        encrypted_data = fernet_encrypt(src, password.encode("ascii"))
        with open(dst, "wb") as fout:
            fout.write(encrypted_data)

        return dst

    def decrypt(self, src: str, password: str) -> str:
        dstfd, dst = tempfile.mkstemp()
        decrypted_data = fernet_decrypt(src, password.encode("ascii"))
        with open(dst, "wb") as fout:
            fout.write(decrypted_data)

        return dst

    def decrypt_or_decrypt_args(
        self,
        src: str,
        dst: str,
        decrypt_password: Union[None, str],
        encrypt_password: Union[None, str],
        env: dict,
    ) -> Tuple[str, str]:
        if decrypt_password:
            decrypt_password = self.jinja_expand_str(decrypt_password, env)
            src = self.decrypt(src, decrypt_password)
        if encrypt_password:
            encrypt_password = self.jinja_expand_str(encrypt_password, env)
            src = self.encrypt(src, encrypt_password)

        return src, dst

    def do_vars(self, **kv):
        self.config.update(self.jinja_expand_dict(kv))

    #  deprecated: Renamed "config" to "vars"
    do_config = do_vars

    def do_copy(
        self,
        src: str,
        dst: str,
        skip: bool = False,
        decrypt_password: Union[None, str] = None,
        encrypt_password: Union[None, str] = None,
    ):
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        dst = self.jinja_expand_str(dst, env)
        src, dst = self.decrypt_or_decrypt_args(
            src, dst, decrypt_password, encrypt_password, env
        )

        print(f"copy({src}  {dst})")
        if skip == "if_exists" and os.path.exists(dst):
            print("Exists")
            return

        shutil.copy(src, dst)

    def do_template(
        self,
        src: str,
        dst: str,
        skip: bool = False,
        decrypt_password: Union[None, str] = None,
        encrypt_password: Union[None, str] = None,
    ):
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        dst = self.jinja_expand_str(dst, env)
        src, dst = self.decrypt_or_decrypt_args(
            src, dst, decrypt_password, encrypt_password, env
        )

        print(f"template({src}  {dst})")
        if skip == "exists" and os.path.exists(dst):
            print("Exists")
            return

        with open(src, "r") as fin:
            data = self.jinja_expand_str(fin.read(), env)
        with open(dst, "w") as fout:
            fout.write(data)

    def do_mkdir(self, path: str, skip: bool = False):
        path = self.jinja_expand_str(path)
        print(f"mkdir({path})")
        if skip == "if_exists" and os.path.exists(path):
            print("Exists")
            return

        os.makedirs(path)

    def do_rm(self, path: str, recursive: bool = False):
        path = self.jinja_expand_str(path)
        print(f"rm({path})")
        if not os.path.exists(path):
            return

        if recursive and os.path.isdir(path):
            shutil.rmtree(path)
            return

        os.remove(path)

    def do_run(self, command: str):
        command = self.jinja_expand_str(command)
        print(f"run({command})")
        sys.stdout.flush()
        sys.stderr.flush()
        subprocess.run(command, shell=True)

    def do_cd(self, path: str):
        path = self.jinja_expand_str(path)
        print(f"cd({path})")
        os.chdir(path)


if __name__ == "__main__":
    runner = CommandProcessor()

    data = ordered_load(open(sys.argv[1], "r"), yaml.SafeLoader)
    data = unroll_loops(data)
    for statement in data:
        command = list(statement.keys())[0]
        del statement[command]
        args = statement

        try:
            attr = getattr(runner, f"do_{command}")
        except AttributeError:
            sys.stderr.write(f'ERROR: Unknown command "{command}"')
            sys.exit(1)
        attr(**args)
