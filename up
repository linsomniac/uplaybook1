#!/usr/bin/env python3


import sys
import os
import jinja2
import subprocess
import tempfile
import shutil
import gnupg
import yaml
from collections import OrderedDict
from typing import Union
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC


def ordered_load(stream, Loader=yaml.SafeLoader, object_pairs_hook=OrderedDict):
    """Usage:
    ordered_load(stream, yaml.SafeLoader)
    From: https://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-mappings-as-ordereddicts
    """

    class OrderedLoader(Loader):
        pass

    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))

    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping
    )
    return yaml.load(stream, OrderedLoader)


def fernet_decrypt(data: bytes, password: bytes) -> bytes:
    salt = password
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=480000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(password))
    f = Fernet(key)
    return f.decrypt(data)


class CommandProcessor:
    def __init__(self):
        self.config = {"environ": os.environ}

    def jinja_expand_str(self, s: str, env: Union[None, dict] = None) -> str:
        env = self.config.copy()
        if env != None:
            env.update(env)
        return jinja2.Template(s).render(env)

    def jinja_expand_dict(self, d: dict) -> dict:
        env = self.config.copy()
        results = {}
        for k, v in d.items():
            newv = jinja2.Template(v).render(env)
            env[k] = newv
            results[k] = newv

        return results

    def decrypt(self, src: str, password: str) -> str:
        dstfd, dst = tempfile.mkstemp()
        with open(src, "rb") as fin:
            decrypted_data = fernet_decrypt(fin.read(), password.encode('ascii'))
            with open(dst, "wb") as fout:
                fout.write(decrypted_data)

        return dst

    def do_config(self, **kv):
        self.config.update(self.jinja_expand_dict(kv))

    def do_copy(
        self,
        src: str,
        dst: str,
        skip: bool = False,
        decrypt_password: Union[None, str] = None,
    ):
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        if decrypt_password:
            decrypt_password = self.jinja_expand_str(decrypt_password, env)
            src = self.decrypt(src, decrypt_password)
        dst = self.jinja_expand_str(dst, env)

        print(f"copy({src}  {dst})")
        if skip == "if_exists" and os.path.exists(dst):
            print("Exists")
            return

        shutil.copy(src, dst)

    def do_mkdir(self, path: str, skip: bool = False):
        path = self.jinja_expand_str(path)
        print(f"mkdir({path})")
        if skip == "if_exists" and os.path.exists(path):
            print("Exists")
            return

        os.makedirs(path)

    def do_template(self, src: str, dst: str, skip: bool = False):
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        dst = self.jinja_expand_str(dst, env)

        print(f"template({src}  {dst})")
        if skip == "exists" and os.path.exists(dst):
            print("Exists")
            return

        with open(src, "r") as fin:
            data = self.jinja_expand_str(fin.read(), env)
        with open(dst, "w") as fout:
            fout.write(data)

    def do_rm(self, path: str, recursive: bool = False):
        path = self.jinja_expand_str(path)
        print(f"rm({path})")
        if not os.path.exists(path):
            return

        if recursive and os.path.isdir(path):
            shutil.rmtree(path)
            return

        os.remove(path)

    def do_run(self, command: str):
        command = self.jinja_expand_str(command)
        print(f"run({command})")
        sys.stdout.flush()
        sys.stderr.flush()
        subprocess.run(command, shell=True)

    def do_cd(self, path: str):
        path = self.jinja_expand_str(path)
        print(f"cd({path})")
        os.chdir(path)


if __name__ == "__main__":
    runner = CommandProcessor()

    data = ordered_load(open(sys.argv[1], "r"), yaml.SafeLoader)
    for statement in data:
        command = list(statement.keys())[0]
        del statement[command]
        args = statement

        try:
            attr = getattr(runner, f"do_{command}")
        except AttributeError:
            sys.stderr.write(f'ERROR: Unknown command "{command}"')
            sys.exit(1)
        attr(**args)
