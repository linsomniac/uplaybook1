#!/usr/bin/env python3


import sys
import os
import jinja2
import subprocess
import tempfile
import shutil
import re
import yaml
import random
from collections import OrderedDict
from typing import Union, Tuple, List, Iterator
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from pathlib import Path
import argparse
import time as time_module


def find_playbook(playbookname: str) -> Path:
    """
    Finds and returns the path of a specified playbook file.

    Searches for a playbook file with the given name in predefined directories
    and with specific extensions (.yaml, .yml, or no extension). If the file is
    inside a directory, it searches for 'playbook' files with the same extensions
    within. The UP_PLAYBOOK_PATH environment variable can be used to set a custom
    search path.

    Args:
    playbookname (str): The name of the playbook file to search for.

    Returns:
    Path: The path of the found playbook file.

    Raises:
    FileNotFoundError: If the playbook file is not found in the search paths."""

    search_path = os.environ.get(
        "UP_PLAYBOOK_PATH",
        ".:.uplaybooks:~/.config/uplaybook/books:~/.config/uplaybook",
    )
    playbook_paths = [
        Path(x).expanduser().joinpath(playbookname) for x in search_path.split(":")
    ]

    def playbook_combinations(paths: List[Path]) -> Iterator[Path]:
        for pb in paths:
            yield pb.joinpath("up.yml")  #  pb/up.yml
            yield pb  #  pb
            yield pb.parent.joinpath(pb.name + ".yml")  #  pb.yml

    for pb in playbook_combinations(playbook_paths):
        if pb.exists():
            return pb

    raise FileNotFoundError(
        f"Unable to locate a playbook by the name of {playbookname},"
        f" searched in path {search_path}"
    )


def ordered_load(stream, Loader=yaml.SafeLoader, object_pairs_hook=OrderedDict):
    """Usage:
    ordered_load(stream, yaml.SafeLoader)
    From: https://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-mappings-as-ordereddicts
    """

    class OrderedLoader(Loader):
        pass

    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))

    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping
    )
    return yaml.load(stream, OrderedLoader)


def unroll_loops(lst: List[OrderedDict]) -> List[OrderedDict]:
    """
    Unroll dictionaries containing a "loop" key with a list of dictionaries as its value.

    This function iterates through a list of dictionaries, and if an item
    has a "loop" key, it replaces the item with one item for each of the
    elements in the "loop" value list.  The new items are created by merging
    the outer dictionary with each inner dictionary, overwriting any keys
    in the outer dictionary with the values from the inner dictionary.

    Args:
        lst (List[OrderedDict]): A list of dictionaries, with some dictionaries
                potentially containing a "loop" key and a list of dictionaries as
                its value.

    Returns:
        List[OrderedDict]: A new list of dictionaries with the "loop" items unrolled.
    """
    result = []
    for task in lst:
        if "loop" in task:
            for item in task["loop"]:
                merged = OrderedDict()
                merged.update(task)
                merged.update(item)
                del merged["loop"]
                result.append(merged)
        else:
            result.append(task)
    return result


def timestr_to_secs(timestr: str) -> int:
    """
    Convert a time string to the number of seconds it represents.
    """
    if not timestr:
        raise ValueError(f"Time string cannot be empty")

    rx = (
        r"^((?P<random>random)\s+)?((?P<days>\d+)(d|days?)\s*)?((?P<hours>\d+)"
        r"(h|hr|hours?)\s*)?((?P<minutes>\d+)(m|min|minutes?)\s*)?((?P<seconds>\d+)"
        r"(s|sec|seconds?)?\s*)?(?P<random2>random)?$"
    )
    m = re.match(rx, timestr)
    if not m:
        raise ValueError(f'Unable to parse time string: "{timestr}"')

    groups = m.groupdict()
    seconds = 0
    for group, mult in (
        ("seconds", 1),
        ("minutes", 60),
        ("hours", 3600),
        ("days", 86400),
    ):
        if groups[group] is not None:
            seconds += int(groups[group]) * mult

    if groups["random"] is not None or groups["random2"] is not None:
        seconds = random.randint(1, seconds)
    return seconds


def generate_salt() -> bytes:
    '''Generate a random 16 byte salt for fernet encryption.'''
    return os.urandom(16)


def fernet_key(password: bytes, salt: bytes) -> Fernet:
    '''Create a Fernet encryption object for the given password with the salt.

    An "up" Fernet file is 16 random bytes followed by the encrypted data.  For encryption,
    pass in a random salt.  For decryption, read the first 16 bytes of the encrypted file,
    and pass that in here as the salt, then use the returned object to decrypt the rest of
    the file.

    Arguments:
        - password: The password for de/encryption.
        - salt: 16 bytes of salt.

    Returns:
        - Fernet() object for encryption/decryption.
    '''
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=960000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(password))
    return Fernet(key)


def fernet_encrypt(filename: str, password: bytes) -> bytes:
    salt = generate_salt()
    f = fernet_key(password, salt)
    with open(filename, "rb") as fp:
        return salt + f.encrypt(fp.read())


def fernet_decrypt(filename: str, password: bytes) -> bytes:
    with open(filename, "rb") as fp:
        salt = fp.read(16)
        f = fernet_key(password, salt)
        return f.decrypt(fp.read())


class CommandProcessor:
    def __init__(self, template_dir: Path, playbook_name: Union[str, Path]) -> None:
        self.globals = {"environ": os.environ, "os": os}

        self.jinja_env = jinja2.Environment()
        self.jinja_env.filters["basename"] = os.path.basename
        self.jinja_env.filters["dirname"] = os.path.dirname
        self.jinja_env.filters["abspath"] = os.path.abspath
        self.template_dir = template_dir
        self.playbook_name = str(playbook_name)
        self.set_remaining_args(sys.argv[1:])

    def debug(self, msg):
        if not self.globals.get("up_debug"):
            return
        print(msg)

    def set(self, var: str, value) -> None:
        """Set a global value"""
        self.globals[var] = value

    def set_remaining_args(self, remaining_args: List) -> None:
        """Store the remaining command-line arguments after they have been parsed so far"""
        self.remaining_args = remaining_args

    def jinja_expand_str_none(
        self, s: Union[str, None], env_in: Union[None, dict] = None
    ) -> Union[str, None]:
        """Jinja2 template expand `s` using the environment `env_in`.
        If `s` is None, return None, otherwise return the template expanded version of `s`."""
        if s is None:
            return None
        return self.jinja_expand_str(s, env_in)

    def jinja_expand_str(self, s: str, env_in: Union[None, dict] = None) -> str:
        """Jinja2 template expand `s` using the environment `env_in`."""
        env = self.globals.copy()
        if env_in != None:
            env.update(env_in)
        return self.jinja_env.from_string(s).render(env)

    def run_tasks(self, tasks: List) -> None:
        """Run the given playbook tasks."""
        for statement in tasks:
            command = list(statement.keys())[0]
            command_value = statement[command]
            args = statement.copy()
            del args[command]

            try:
                func = getattr(self, f"do_{command}")
            except AttributeError:
                sys.stderr.write(f'ERROR: Unknown command "{command}"')
                sys.exit(1)
            func(command_value, **args)

            self.previous_command = command

    def find_file(self, filename: str) -> Path:
        """
        Finds and returns the path of a template/file.

        This function uses a colon-separated search path, either gotten from the
        UP_TEMPLATE_PATH environment variable or the default.  "." specified in
        the search path is relative to the directory the playbook is found in.

        Returns:
        Path: The path of the found template file.

        Raises:
        FileNotFoundError: If the template file is not found in the search paths.
        """
        search_path = os.environ.get("UP_FILES_PATH", ".:./files")

        for directory in search_path.split(":"):
            if directory == ".":
                p = self.template_dir.joinpath(filename)
                if p.exists():
                    return p
                continue
            if directory.startswith("./"):
                p = self.template_dir.joinpath(directory[2:]).joinpath(filename)
                if p.exists():
                    return p
                continue

            p = Path(directory).joinpath(filename)
            if p.exists():
                return p

        raise FileNotFoundError(
            f"Could not find template {filename}, searched in {search_path}"
        )

    def evaluate(self, condition: Union[str, bool]) -> bool:
        """
        Determines if the given condition is True or False.

        This function accepts a condition that can be either a boolean value or a string
        representing a boolean expression.  If the condition is already a boolean value
        (due to a "false" in yaml), it returns the same value. If the condition is a
        string, the function evaluates the boolean expression and returns the result.

        The `eval` function is used to evaluate the expression, and the evaluation
        is performed in the context of the `self.globals` dictionary. Any variables
        used in the expression should be defined in this dictionary.

        Parameters
        ----------
        condition : Union[str, bool]
            The condition to evaluate.

        Returns
        -------
        bool
            The result of evaluating the condition.

        Raises
        ------
        TypeError
            If the `condition` is not a boolean value or a string.
        SyntaxError
            If the `condition` is a string with an invalid boolean expression.

        Examples
        --------
        >>> evaluate(True)
        True
        >>> evaluate(False)
        False
        >>> evaluate("3 > 2")
        True
        >>> evaluate("5 < 2")
        False
        """
        if condition is False:
            return False
        if condition is True:
            return True
        ret = eval(condition, self.globals)
        return ret

    def jinja_expand_dict(self, d: dict) -> dict:
        env = self.globals.copy()
        env.update(d)
        results = {}
        for k, v in d.items():
            if type(v) is not type(str):
                results[k] = v
                env[k] = str(v)
                continue
            newv = self.jinja_env.from_string(v).render(env)
            env[k] = newv
            results[k] = newv

        return results

    def encrypt(self, src: str, password: str) -> str:
        dstfd, dst = tempfile.mkstemp()
        encrypted_data = fernet_encrypt(src, password.encode("ascii"))
        with open(dst, "wb") as fout:
            fout.write(encrypted_data)

        return dst

    def decrypt(self, src: str, password: str) -> str:
        dstfd, dst = tempfile.mkstemp()
        decrypted_data = fernet_decrypt(src, password.encode("ascii"))
        with open(dst, "wb") as fout:
            fout.write(decrypted_data)

        return dst

    def decrypt_or_decrypt_args(
        self,
        src: str,
        dst: str,
        decrypt_password: Union[None, str],
        encrypt_password: Union[None, str],
        env: dict,
    ) -> Tuple[str, str]:
        if decrypt_password:
            decrypt_password = self.jinja_expand_str(decrypt_password, env)
            src = self.decrypt(src, decrypt_password)
        if encrypt_password:
            encrypt_password = self.jinja_expand_str(encrypt_password, env)
            src = self.encrypt(src, encrypt_password)

        return src, dst

    def do_args(self, _, schema) -> None:
        parser = argparse.ArgumentParser(prog=f"up:{self.playbook_name}")
        for arg in schema:
            kw_args = {
                "type": str,
            }
            orig_arg_name = arg["name"]
            arg_name = arg["name"].replace("_", "-")
            if "default" in arg:
                kw_args["dest"] = arg_name
                arg_name = "--" + arg_name
                kw_args["default"] = arg["default"]
            #  @@@ Can query from user by adding the following:
            #  @@@ And then looking for missing arguments not in "args" at the end
            # else:
            #    arg_name = '--' + arg_name
            #    kw_args['default'] = argparse.SUPPRESS
            if "description" in arg:
                kw_args["help"] = arg["description"]
            if "type" in arg:
                kw_args["type"] = {"bool": bool, "str": str, "int": int}[arg["type"]]
            if kw_args["type"] is bool:
                kw_args["action"] = argparse.BooleanOptionalAction

            parser.add_argument(arg_name, **kw_args)
        args, remaining = parser.parse_known_args(self.remaining_args)
        self.set_remaining_args(remaining)

        args_vars = vars(args)
        for arg in schema:
            self.globals[arg["name"]] = args_vars[arg["name"].replace("_", "-")]

    def do_vars(self, _, **kv) -> None:
        self.globals.update(self.jinja_expand_dict(kv))

    #  deprecated: Renamed "config" to "vars"
    do_config = do_vars

    def do_copy(
        self,
        _,
        src: str,
        dst: str,
        skip: bool = False,
        decrypt_password: Union[None, str] = None,
        encrypt_password: Union[None, str] = None,
    ) -> None:
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        dst = self.jinja_expand_str(dst, env)
        src, dst = self.decrypt_or_decrypt_args(
            src, dst, decrypt_password, encrypt_password, env
        )

        self.debug(f"copy({src}  {dst})")
        if skip == "if_exists" and os.path.exists(dst):
            self.debug("Exists")
            return

        if "/" not in src:
            src = str(self.find_file(src))

        shutil.copy(src, dst)

    def do_template(
        self,
        _,
        src: str,
        dst: str,
        skip: bool = False,
        decrypt_password: Union[None, str] = None,
        encrypt_password: Union[None, str] = None,
    ) -> None:
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        dst = self.jinja_expand_str(dst, env)
        src, dst = self.decrypt_or_decrypt_args(
            src, dst, decrypt_password, encrypt_password, env
        )

        self.debug(f"template({src}  {dst})")
        if skip == "exists" and os.path.exists(dst):
            self.debug("Exists")
            return

        if "/" not in src:
            src = str(self.find_file(src))

        with open(src, "r") as fin:
            data = self.jinja_expand_str(fin.read(), env)
        with open(dst, "w") as fout:
            fout.write(data)

    def do_mkdir(self, _, path: str, skip: bool = False) -> None:
        path = self.jinja_expand_str(path)
        self.debug(f"mkdir({path})")
        if skip == "if_exists" and os.path.exists(path):
            self.debug("Exists")
            return

        os.makedirs(path)

    def do_rm(self, _, path: str, recursive: bool = False) -> None:
        path = self.jinja_expand_str(path)
        self.debug(f"rm({path})")
        if not os.path.exists(path):
            return

        if recursive and os.path.isdir(path):
            shutil.rmtree(path)
            return

        os.remove(path)

    def do_run(self, _, command: str) -> None:
        command = self.jinja_expand_str(command)
        self.debug(f"run({command})")
        sys.stdout.flush()
        sys.stderr.flush()
        subprocess.run(command, shell=True)

    def do_cd(self, _, path: str) -> None:
        path = self.jinja_expand_str(path)
        self.debug(f"cd({path})")
        os.chdir(path)

    def do_echo(
        self, _, msg: Union[str, None] = None, stderr: Union[str, None] = None
    ) -> None:
        stderr = self.jinja_expand_str_none(stderr)
        msg = self.jinja_expand_str_none(msg)
        self.debug(f"echo(msg={msg}, stderr={stderr})")
        if stderr is not None:
            sys.stderr.write(stderr + "\n")
        if msg is not None:
            print(msg)
        if stderr is None and msg is None:
            print()

    def do_if(self, _, condition: str, tasks: List) -> None:
        condition = self.jinja_expand_str(condition)
        self.debug(f"if({condition})")
        self.last_if_result = self.evaluate(condition)
        if not self.last_if_result:
            return
        self.run_tasks(tasks)

    def do_elif(self, _, condition: str, tasks: List) -> None:
        condition = self.jinja_expand_str(condition)
        self.debug(f"elif({condition})")
        if self.previous_command not in ["if", "elif"]:
            raise ValueError('"elif" can only occur after a "if" or "elif"')
        if self.last_if_result:
            return
        self.last_if_result = self.evaluate(condition)
        if not self.last_if_result:
            return
        self.run_tasks(tasks)

    def do_else(self, _, tasks: List) -> None:
        self.debug(f"elif()")
        if self.previous_command not in ["if", "elif"]:
            raise ValueError('"else" can only occur after a "if" or "elif"')
        if self.last_if_result:
            return
        self.run_tasks(tasks)

    def do_exit(
        self,
        _,
        code: Union[int, str] = 0,
        msg: Union[str, None] = None,
        stderr: Union[str, None] = None,
    ) -> None:
        stderr = self.jinja_expand_str_none(stderr)
        msg = self.jinja_expand_str_none(msg)
        self.debug(f"exit({code}, msg={msg}, stderr={stderr})")
        if stderr is not None:
            sys.stderr.write(stderr + "\n")
        if msg is not None:
            print(msg)
        sys.exit(int(code))

    def do_pause(self, _, time: str) -> None:
        time = self.jinja_expand_str(time)
        time_module.sleep(timestr_to_secs(time))

    def do_stat(self, _, path: str, register: Union[str, None] = None) -> None:
        path = self.jinja_expand_str(path)
        self.debug(f"stat({path})")
        stat = os.stat(path)
        if register:
            self.globals[register] = stat

    def do_umask(self, _, mask: Union[str, int], register: Union[str, None] = None) -> None:
        if type(mask) == str:
            mask = self.jinja_expand_str(mask)
            mask = int(mask, 8)
        self.debug(f"umask({mask:o})")
        old_mask = os.umask(mask)
        if register:
            self.globals[register] = old_mask


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="up",
        description="Run playbooks of actions, typically to set up some sort of environment.",
        add_help=False,
    )
    parser.add_argument("--up-debug", action="store_true")
    parser.add_argument("playbook")
    args, remaining_args = parser.parse_known_args()

    playbook_file = find_playbook(args.playbook)

    data = ordered_load(open(playbook_file, "r"), yaml.SafeLoader)
    data = unroll_loops(data)
    runner = CommandProcessor(playbook_file.parent, playbook_file.name)
    runner.set_remaining_args(remaining_args)
    if args.up_debug:
        runner.set("up_debug", True)
    runner.run_tasks(data)
