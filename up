#!/usr/bin/env python3


import sys
import os
import jinja2
import subprocess
import tempfile
import shutil
import yaml
from collections import OrderedDict
from typing import Union, Tuple, List, Iterator
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from pathlib import Path
import argparse


def find_playbook(playbookname: str) -> Path:
    """
    Finds and returns the path of a specified playbook file.

    Searches for a playbook file with the given name in predefined directories
    and with specific extensions (.yaml, .yml, or no extension). If the file is
    inside a directory, it searches for 'playbook' files with the same extensions
    within. The UP_PLAYBOOK_PATH environment variable can be used to set a custom
    search path.

    Args:
    playbookname (str): The name of the playbook file to search for.

    Returns:
    Path: The path of the found playbook file.

    Raises:
    FileNotFoundError: If the playbook file is not found in the search paths."""

    search_path = os.environ.get(
        "UP_PLAYBOOK_PATH",
        ".:.uplaybooks:~/.config/uplaybook/books:~/.config/uplaybook",
    )
    playbook_paths = [
        Path(x).expanduser().joinpath(playbookname) for x in search_path.split(":")
    ]

    def playbook_combinations(paths: List[Path]) -> Iterator[Path]:
        for pb in paths:
            yield pb.joinpath("up.yml")  #  pb/up.yml
            yield pb  #  pb
            yield pb.parent.joinpath(pb.name + ".yml")  #  pb.yml

    for pb in playbook_combinations(playbook_paths):
        if pb.exists():
            return pb

    raise FileNotFoundError(
        f"Unable to locate a playbook by the name of {playbookname},"
        f" searched in path {search_path}"
    )


def ordered_load(stream, Loader=yaml.SafeLoader, object_pairs_hook=OrderedDict):
    """Usage:
    ordered_load(stream, yaml.SafeLoader)
    From: https://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-mappings-as-ordereddicts
    """

    class OrderedLoader(Loader):
        pass

    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))

    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping
    )
    return yaml.load(stream, OrderedLoader)


def unroll_loops(lst: List[OrderedDict]) -> List[OrderedDict]:
    """
    Unroll dictionaries containing a "loop" key with a list of dictionaries as its value.

    This function iterates through a list of dictionaries, and if an item
    has a "loop" key, it replaces the item with one item for each of the
    elements in the "loop" value list.  The new items are created by merging
    the outer dictionary with each inner dictionary, overwriting any keys
    in the outer dictionary with the values from the inner dictionary.

    Args:
        lst (List[OrderedDict]): A list of dictionaries, with some dictionaries
                potentially containing a "loop" key and a list of dictionaries as
                its value.

    Returns:
        List[OrderedDict]: A new list of dictionaries with the "loop" items unrolled.
    """
    result = []
    for task in lst:
        if "loop" in task:
            for item in task["loop"]:
                merged = OrderedDict()
                merged.update(task)
                merged.update(item)
                del merged["loop"]
                result.append(merged)
        else:
            result.append(task)
    return result


def generate_salt() -> bytes:
    return os.urandom(16)


def fernet_key(password: bytes, salt: bytes) -> Fernet:
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=960000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(password))
    return Fernet(key)


def fernet_encrypt(filename: str, password: bytes) -> bytes:
    salt = generate_salt()
    f = fernet_key(password, salt)
    with open(filename, "rb") as fp:
        return salt + f.encrypt(fp.read())


def fernet_decrypt(filename: str, password: bytes) -> bytes:
    with open(filename, "rb") as fp:
        salt = fp.read(16)
        f = fernet_key(password, salt)
        return f.decrypt(fp.read())


class CommandProcessor:
    def __init__(self, template_dir: Path, playbook_name: Union[str, Path]) -> None:
        self.globals = {"environ": os.environ, "os": os}

        self.jinja_env = jinja2.Environment()
        self.jinja_env.filters["basename"] = os.path.basename
        self.jinja_env.filters["dirname"] = os.path.dirname
        self.jinja_env.filters["abspath"] = os.path.abspath
        self.template_dir = template_dir
        self.playbook_name = str(playbook_name)

    def jinja_expand_str(self, s: str, env_in: Union[None, dict] = None) -> str:
        env = self.globals.copy()
        if env_in != None:
            env.update(env_in)
        return self.jinja_env.from_string(s).render(env)

    def find_file(self, filename: str) -> Path:
        """
        Finds and returns the path of a template/file.

        This function uses a colon-separated search path, either gotten from the
        UP_TEMPLATE_PATH environment variable or the default.  "." specified in
        the search path is relative to the directory the playbook is found in.

        Returns:
        Path: The path of the found template file.

        Raises:
        FileNotFoundError: If the template file is not found in the search paths.
        """
        search_path = os.environ.get("UP_FILES_PATH", ".:./files")

        for directory in search_path.split(":"):
            if directory == ".":
                p = self.template_dir.joinpath(filename)
                if p.exists():
                    return p
                continue
            if directory.startswith("./"):
                p = self.template_dir.joinpath(directory[2:]).joinpath(filename)
                if p.exists():
                    return p
                continue

            p = Path(directory).joinpath(filename)
            if p.exists():
                return p

        raise FileNotFoundError(
            f"Could not find template {filename}, searched in {search_path}"
        )

    def evaluate(self, condition: Union[str, bool]) -> bool:
        """
        Determines if the given condition is True or False.

        This function accepts a condition that can be either a boolean value or a string
        representing a boolean expression.  If the condition is already a boolean value
        (due to a "false" in yaml), it returns the same value. If the condition is a
        string, the function evaluates the boolean expression and returns the result.

        The `eval` function is used to evaluate the expression, and the evaluation
        is performed in the context of the `self.globals` dictionary. Any variables
        used in the expression should be defined in this dictionary.

        Parameters
        ----------
        condition : Union[str, bool]
            The condition to evaluate.

        Returns
        -------
        bool
            The result of evaluating the condition.

        Raises
        ------
        TypeError
            If the `condition` is not a boolean value or a string.
        SyntaxError
            If the `condition` is a string with an invalid boolean expression.

        Examples
        --------
        >>> evaluate(True)
        True
        >>> evaluate(False)
        False
        >>> evaluate("3 > 2")
        True
        >>> evaluate("5 < 2")
        False
        """
        if condition is False:
            return False
        if condition is True:
            return True
        ret = eval(condition, self.globals)
        return ret


    def jinja_expand_dict(self, d: dict) -> dict:
        env = self.globals.copy()
        env.update(d)
        results = {}
        for k, v in d.items():
            if type(v) is not type(str):
                results[k] = v
                env[k] = str(v)
                continue
            newv = self.jinja_env.from_string(v).render(env)
            env[k] = newv
            results[k] = newv

        return results

    def encrypt(self, src: str, password: str) -> str:
        dstfd, dst = tempfile.mkstemp()
        encrypted_data = fernet_encrypt(src, password.encode("ascii"))
        with open(dst, "wb") as fout:
            fout.write(encrypted_data)

        return dst

    def decrypt(self, src: str, password: str) -> str:
        dstfd, dst = tempfile.mkstemp()
        decrypted_data = fernet_decrypt(src, password.encode("ascii"))
        with open(dst, "wb") as fout:
            fout.write(decrypted_data)

        return dst

    def decrypt_or_decrypt_args(
        self,
        src: str,
        dst: str,
        decrypt_password: Union[None, str],
        encrypt_password: Union[None, str],
        env: dict,
    ) -> Tuple[str, str]:
        if decrypt_password:
            decrypt_password = self.jinja_expand_str(decrypt_password, env)
            src = self.decrypt(src, decrypt_password)
        if encrypt_password:
            encrypt_password = self.jinja_expand_str(encrypt_password, env)
            src = self.encrypt(src, encrypt_password)

        return src, dst

    def do_args(self, _, schema) -> None:
        parser = argparse.ArgumentParser(prog=f'up:{self.playbook_name}')
        for arg in schema:
            kw_args = {'type': str, }
            orig_arg_name = arg['name']
            arg_name = arg['name'].replace('_', '-')
            if 'default' in arg:
                kw_args['dest'] = arg_name
                arg_name = '--' + arg_name
                kw_args['default'] = arg['default']
            #  @@@ Can query from user by adding the following:
            #  @@@ And then looking for missing arguments not in "args" at the end
            #else:
            #    arg_name = '--' + arg_name
            #    kw_args['default'] = argparse.SUPPRESS
            if 'description' in arg:
                kw_args['help'] = arg['description']
            if 'type' in arg:
                kw_args['type'] = {'bool': bool, 'str': str, 'int': int}[arg['type']]
            if kw_args['type'] is bool:
                kw_args['action'] = argparse.BooleanOptionalAction

            parser.add_argument(arg_name, **kw_args)
        args = parser.parse_args(sys.argv[2:])

        args_vars = vars(args)
        for arg in schema:
            self.globals[arg['name']] = args_vars[arg['name'].replace('_', '-')]

    def do_vars(self, _, **kv) -> None:
        self.globals.update(self.jinja_expand_dict(kv))

    #  deprecated: Renamed "config" to "vars"
    do_config = do_vars

    def do_copy(
        self, _,
        src: str,
        dst: str,
        skip: bool = False,
        decrypt_password: Union[None, str] = None,
        encrypt_password: Union[None, str] = None,
    ) -> None:
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        dst = self.jinja_expand_str(dst, env)
        src, dst = self.decrypt_or_decrypt_args(
            src, dst, decrypt_password, encrypt_password, env
        )

        print(f"copy({src}  {dst})")
        if skip == "if_exists" and os.path.exists(dst):
            print("Exists")
            return

        if "/" not in src:
            src = str(self.find_file(src))

        shutil.copy(src, dst)

    def do_template(
        self, _,
        src: str,
        dst: str,
        skip: bool = False,
        decrypt_password: Union[None, str] = None,
        encrypt_password: Union[None, str] = None,
    ) -> None:
        env = {"src": src, "dst": dst}
        src = self.jinja_expand_str(src, env)
        dst = self.jinja_expand_str(dst, env)
        src, dst = self.decrypt_or_decrypt_args(
            src, dst, decrypt_password, encrypt_password, env
        )

        print(f"template({src}  {dst})")
        if skip == "exists" and os.path.exists(dst):
            print("Exists")
            return

        if "/" not in src:
            src = str(self.find_file(src))

        with open(src, "r") as fin:
            data = self.jinja_expand_str(fin.read(), env)
        with open(dst, "w") as fout:
            fout.write(data)

    def do_mkdir(self, _, path: str, skip: bool = False) -> None:
        path = self.jinja_expand_str(path)
        print(f"mkdir({path})")
        if skip == "if_exists" and os.path.exists(path):
            print("Exists")
            return

        os.makedirs(path)

    def do_rm(self, _, path: str, recursive: bool = False) -> None:
        path = self.jinja_expand_str(path)
        print(f"rm({path})")
        if not os.path.exists(path):
            return

        if recursive and os.path.isdir(path):
            shutil.rmtree(path)
            return

        os.remove(path)

    def do_run(self, _, command: str) -> None:
        command = self.jinja_expand_str(command)
        print(f"run({command})")
        sys.stdout.flush()
        sys.stderr.flush()
        subprocess.run(command, shell=True)

    def do_cd(self, _, path: str) -> None:
        path = self.jinja_expand_str(path)
        print(f"cd({path})")
        os.chdir(path)

    def do_echo(self, _, msg: str) -> None:
        print(self.jinja_expand_str(msg))

    def do_if(self, _, condition: str, tasks) -> None:
        self.last_if_result = self.evaluate(condition)
        if not self.last_if_result:
            return
        self.run_tasks(tasks)

    def do_elif(self, _, condition: str, tasks) -> None:
        if self.previous_command not in ['if', 'elif']:
            raise ValueError('"elif" can only occur after a "if" or "elif"')
        if self.last_if_result:
            return
        self.last_if_result = self.evaluate(condition)
        if not self.last_if_result:
            return
        self.run_tasks(tasks)

    def do_else(self, _, tasks) -> None:
        if self.previous_command not in ['if', 'elif']:
            raise ValueError('"else" can only occur after a "if" or "elif"')
        if self.last_if_result:
            return
        self.run_tasks(tasks)

    def run_tasks(self, tasks: List) -> None:
        for statement in tasks:
            command = list(statement.keys())[0]
            command_value = statement[command]
            args = statement.copy()
            del(args[command])

            try:
                func = getattr(self, f"do_{command}")
            except AttributeError:
                sys.stderr.write(f'ERROR: Unknown command "{command}"')
                sys.exit(1)
            func(command_value, **args)

            self.previous_command = command


if __name__ == "__main__":
    playbook_file = find_playbook(sys.argv[1])

    data = ordered_load(open(playbook_file, "r"), yaml.SafeLoader)
    data = unroll_loops(data)
    runner = CommandProcessor(playbook_file.parent, playbook_file.name)
    runner.run_tasks(data)
